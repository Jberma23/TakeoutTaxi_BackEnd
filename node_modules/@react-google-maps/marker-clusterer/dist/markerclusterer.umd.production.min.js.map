{"version":3,"file":"markerclusterer.umd.production.min.js","sources":["../src/ClusterIcon.tsx","../src/Cluster.tsx","../src/Clusterer.tsx"],"sourcesContent":["/* eslint-disable filenames/match-regex */\n/* globals google */\nimport {\n  Cluster\n} from './Cluster'\n\nimport {\n  ClusterIconStyle,\n  ClusterIconInfo\n} from './types'\n\nexport class ClusterIcon {\n  cluster: Cluster;\n  className: string;\n  styles: ClusterIconStyle[];\n  center: google.maps.LatLng | undefined;\n  div: HTMLDivElement | null;\n  sums: ClusterIconInfo | null;\n  visible: boolean;\n  url: string;\n  height: number;\n  width: number;\n  anchorText: number[];\n  anchorIcon: number[];\n  textColor: string;\n  textSize: number;\n  textDecoration: string;\n  fontWeight: string;\n  fontStyle: string;\n  fontFamily: string;\n  backgroundPosition: string;\n\n  boundsChangedListener: google.maps.MapsEventListener | null;\n\n  constructor(cluster: Cluster, styles: ClusterIconStyle[]) {\n    cluster.getClusterer().extend(ClusterIcon, google.maps.OverlayView)\n    this.cluster = cluster\n    this.className = this.cluster.getClusterer().getClusterClass()\n    this.styles = styles\n    this.center = undefined\n    this.div = null\n    this.sums = null\n    this.visible = false\n    this.boundsChangedListener = null\n    this.url = ''\n    this.height = 0\n    this.width = 0\n    this.anchorText = [0, 0]\n    this.anchorIcon = [0, 0]\n    this.textColor = 'black'\n    this.textSize = 11\n    this.textDecoration = 'none'\n    this.fontWeight = 'bold'\n    this.fontStyle = 'normal'\n    this.fontFamily = 'Arial,sans-serif'\n    this.backgroundPosition = '0 0'\n    // @ts-ignore\n    this.setMap(cluster.getMap()) // Note: this causes onAdd to be called\n  }\n\n  onAdd() {\n    let cMouseDownInCluster: boolean\n    let cDraggingMapByCluster: boolean\n\n    this.div = document.createElement(\"div\")\n    this.div.className = this.className\n    if (this.visible) {\n      this.show()\n    }\n\n    // @ts-ignore\n    this.getPanes().overlayMouseTarget.appendChild(this.div)\n\n    // Fix for Issue 157\n    this.boundsChangedListener = google.maps.event.addListener(\n      // @ts-ignore\n      this.getMap(),\n      \"boundschanged\",\n      function boundsChabged() {\n        cDraggingMapByCluster = cMouseDownInCluster\n      }\n    )\n\n    google.maps.event.addDomListener(this.div, \"mousedown\", function onMouseDown() {\n      cMouseDownInCluster = true\n      cDraggingMapByCluster = false\n    })\n\n    // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n    google.maps.event.addDomListener(\n      this.div,\n      \"click\",\n      // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n      (event: Event) => {\n        cMouseDownInCluster = false\n\n        if (!cDraggingMapByCluster) {\n          const markerClusterer = this.cluster.getClusterer()\n\n          /**\n         * This event is fired when a cluster marker is clicked.\n         * @name MarkerClusterer#click\n         * @param {Cluster} c The cluster that was clicked.\n         * @event\n         */\n          google.maps.event.trigger(markerClusterer, \"click\", this.cluster)\n          google.maps.event.trigger(markerClusterer, \"clusterclick\", this.cluster) // deprecated name\n\n          // The default click handler follows. Disable it by setting\n          // the zoomOnClick property to false.\n          if (markerClusterer.getZoomOnClick()) {\n          // Zoom into the cluster.\n            const maxZoom = markerClusterer.getMaxZoom()\n\n            const bounds = this.cluster.getBounds()\n\n            // @ts-ignore\n            markerClusterer.getMap().fitBounds(bounds)\n\n\n            // There is a fix for Issue 170 here:\n            setTimeout(\n              function timeout() {\n              // @ts-ignore\n                markerClusterer.getMap().fitBounds(bounds)\n\n                // Don't zoom beyond the max zoom level\n                // @ts-ignore\n                if (maxZoom !== null && (markerClusterer.getMap().getZoom() > maxZoom)) {\n                // @ts-ignore\n                  markerClusterer.getMap().setZoom(maxZoom + 1)\n                }\n              },\n              100\n            )\n          }\n\n          // Prevent event propagation to the map:\n          event.cancelBubble = true\n\n          if (event.stopPropagation) {\n            event.stopPropagation()\n          }\n        }\n      })\n\n    google.maps.event.addDomListener(\n      this.div,\n      \"mouseover\",\n      // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n      () => {\n        /**\n         * This event is fired when the mouse moves over a cluster marker.\n         * @name MarkerClusterer#mouseover\n         * @param {Cluster} c The cluster that the mouse moved over.\n         * @event\n         */\n        google.maps.event.trigger(\n          this.cluster.getClusterer(),\n          \"mouseover\",\n          this.cluster\n        )\n      }\n    )\n\n    // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n    google.maps.event.addDomListener(\n      this.div,\n      \"mouseout\",\n      // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n      () => {\n        /**\n         * This event is fired when the mouse moves out of a cluster marker.\n         * @name MarkerClusterer#mouseout\n         * @param {Cluster} c The cluster that the mouse moved out of.\n         * @event\n         */\n        google.maps.event.trigger(\n          this.cluster.getClusterer(),\n          \"mouseout\",\n          this.cluster\n        )\n      }\n    )\n  }\n\n  onRemove() {\n    if (\n      this.div &&\n      this.div.parentNode\n    ) {\n      this.hide()\n\n      if (this.boundsChangedListener !== null) {\n        google.maps.event.removeListener(this.boundsChangedListener)\n      }\n\n      google.maps.event.clearInstanceListeners(this.div)\n\n      this.div.parentNode.removeChild(this.div)\n\n      this.div = null\n    }\n  }\n\n  draw () {\n    if (this.visible && this.div !== null && this.center) {\n      const { x, y } = this.getPosFromLatLng(this.center)\n\n      this.div.style.top = y + \"px\"\n      this.div.style.left = x + \"px\"\n    }\n  }\n\n  hide () {\n    if (this.div) {\n      this.div.style.display = \"none\"\n    }\n\n    this.visible = false\n  }\n\n  show () {\n    if (this.div && this.center) {\n      let img = \"\", divTitle = \"\"\n\n      // NOTE: values must be specified in px units\n      const bp = this.backgroundPosition.split(\" \")\n\n      const spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, \"\"), 10)\n\n      const spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, \"\"), 10)\n\n      const pos = this.getPosFromLatLng(this.center)\n\n      if (this.sums === null || typeof this.sums.title === \"undefined\" || this.sums.title === \"\") {\n        divTitle = this.cluster.getClusterer().getTitle()\n      } else {\n        divTitle = this.sums.title\n      }\n\n      this.div.style.cssText = this.createCss(pos)\n\n      img = \"<img alt='\" + divTitle + \"' src='\" + this.url + \"' style='position: absolute; top: \" + spriteV + \"px; left: \" + spriteH + \"px; \"\n\n      //@ts-ignore\n      if (!this.cluster.getClusterer().enableRetinaIcons) {\n        img += \"clip: rect(\" + (-1 * spriteV) + \"px, \" + ((-1 * spriteH) + this.width) + \"px, \" +\n          ((-1 * spriteV) + this.height) + \"px, \" + (-1 * spriteH) + \"px);\"\n      }\n\n      img += \"'>\"\n\n      this.div.innerHTML = img + \"<div style='\" +\n        \"position: absolute;\" +\n        \"top: \" + this.anchorText[0] + \"px;\" +\n        \"left: \" + this.anchorText[1] + \"px;\" +\n        \"color: \" + this.textColor + \";\" +\n        \"font-size: \" + this.textSize + \"px;\" +\n        \"font-family: \" + this.fontFamily + \";\" +\n        \"font-weight: \" + this.fontWeight + \";\" +\n        \"font-style: \" + this.fontStyle + \";\" +\n        \"text-decoration: \" + this.textDecoration + \";\" +\n        \"text-align: center;\" +\n        \"width: \" + this.width + \"px;\" +\n        \"line-height:\" + this.height + \"px;\" +\n        // @ts-ignore\n        \"'>\" + this.sums.text + \"</div>\"\n\n      this.div.title = divTitle\n\n      this.div.style.display = \"\"\n    }\n\n    this.visible = true\n  }\n\n  useStyle (sums: ClusterIconInfo) {\n    this.sums = sums\n\n    const style = this.styles[\n      Math.min(this.styles.length - 1, Math.max(0, sums.index - 1))\n    ]\n\n    this.url = style.url\n    this.height = style.height\n    this.width = style.width\n    this.anchorText = style.anchorText || [0, 0]\n    this.anchorIcon = style.anchorIcon || [this.height / 2, this.width / 2]\n\n    this.textColor = style.textColor || \"black\"\n\n    this.textSize = style.textSize || 11\n\n    this.textDecoration = style.textDecoration || \"none\"\n\n    this.fontWeight = style.fontWeight || \"bold\"\n\n    this.fontStyle = style.fontStyle || \"normal\"\n\n    this.fontFamily = style.fontFamily || \"Arial,sans-serif\"\n\n    this.backgroundPosition = style.backgroundPosition || \"0 0\"\n  }\n\n  setCenter(center: google.maps.LatLng) {\n    this.center = center\n  }\n\n  createCss(pos: google.maps.Point): string {\n    const style = []\n\n    style.push(\"cursor: pointer;\")\n\n    style.push(\"position: absolute; top: \" + pos.y + \"px; left: \" + pos.x + \"px;\")\n\n    style.push(\"width: \" + this.width + \"px; height: \" + this.height + \"px;\")\n\n    return style.join(\"\")\n  }\n\n  getPosFromLatLng(latlng: google.maps.LatLng): google.maps.Point {\n    // @ts-ignore\n    const pos = this.getProjection().fromLatLngToDivPixel(latlng)\n\n    pos.x -= this.anchorIcon[1]\n\n    pos.y -= this.anchorIcon[0]\n\n    pos.x = pos.x\n\n    pos.y = pos.y\n\n    return pos\n  }\n}\n","/* eslint-disable filenames/match-regex */\n/* globals google */\nimport {\n  Clusterer\n} from './Clusterer'\n\nimport {\n  ClusterIcon\n} from './ClusterIcon'\n\nimport {\n  MarkerExtended\n} from './types'\n\nexport class Cluster {\n  markerClusterer: Clusterer;\n  map: google.maps.Map | google.maps.StreetViewPanorama;\n  gridSize: number;\n  minClusterSize: number;\n  averageCenter: boolean;\n  markers: MarkerExtended[];\n  center: google.maps.LatLng | undefined;\n  bounds: google.maps.LatLngBounds | null;\n  clusterIcon: ClusterIcon;\n\n  constructor(markerClusterer: Clusterer) {\n    this.markerClusterer = markerClusterer\n    // @ts-ignore\n    this.map = this.markerClusterer.getMap()\n\n    this.gridSize = this.markerClusterer.getGridSize()\n\n    this.minClusterSize = this.markerClusterer.getMinimumClusterSize()\n\n    this.averageCenter = this.markerClusterer.getAverageCenter()\n\n    this.markers = []\n\n    this.center = undefined\n\n    this.bounds = null\n\n    this.clusterIcon = new ClusterIcon(this, this.markerClusterer.getStyles())\n  }\n\n  getSize (): number {\n    return this.markers.length\n  }\n\n  getMarkers (): MarkerExtended[] {\n    return this.markers\n  }\n\n  getCenter (): google.maps.LatLng | undefined {\n    return this.center\n  }\n\n  getMap (): google.maps.Map | google.maps.StreetViewPanorama {\n    return this.map\n  }\n\n  getClusterer (): Clusterer {\n    return this.markerClusterer\n  }\n\n  getBounds (): google.maps.LatLngBounds {\n    const bounds = new google.maps.LatLngBounds(this.center, this.center)\n\n    const markers = this.getMarkers()\n\n    for (let i = 0; i < markers.length; i++) {\n      const position = markers[i].getPosition()\n\n      if (position) {\n        bounds.extend(position)\n      }\n    }\n\n    return bounds\n  }\n\n  remove () {\n    // @ts-ignore\n    this.clusterIcon.setMap(null)\n\n    this.markers = []\n\n    delete this.markers\n  }\n\n  addMarker (marker: MarkerExtended): boolean {\n    if (this.isMarkerAlreadyAdded(marker)) {\n      return false\n    }\n\n    if (!this.center) {\n      const position = marker.getPosition()\n\n      if (position) {\n        this.center = position\n\n        this.calculateBounds()\n      }\n    } else {\n      if (this.averageCenter) {\n        const position = marker.getPosition()\n\n        if (position) {\n          const length = this.markers.length + 1\n\n          this.center = new google.maps.LatLng(\n            (this.center.lat() * (length - 1) + position.lat()) / length,\n            (this.center.lng() * (length - 1) + position.lng()) / length\n          )\n\n          this.calculateBounds()\n        }\n      }\n    }\n\n    marker.isAdded = true\n\n    this.markers.push(marker)\n\n    const mCount = this.markers.length\n\n    const maxZoom = this.markerClusterer.getMaxZoom()\n\n    if (maxZoom !== null && this.map.getZoom() > maxZoom) {\n      // Zoomed in past max zoom, so show the marker.\n      if (marker.getMap() !== this.map) {\n        marker.setMap(this.map)\n      }\n    } else if (mCount < this.minClusterSize) {\n      // Min cluster size not reached so show the marker.\n      if (marker.getMap() !== this.map) {\n        marker.setMap(this.map)\n      }\n    } else if (mCount === this.minClusterSize) {\n      // Hide the markers that were showing.\n      for (let i = 0; i < mCount; i++) {\n        this.markers[i].setMap(null)\n      }\n    } else {\n      marker.setMap(null)\n    }\n\n    this.updateIcon()\n\n    return true\n  }\n\n  isMarkerInClusterBounds ( marker: MarkerExtended): boolean {\n    if (this.bounds !== null) {\n      const position = marker.getPosition()\n\n      if (position) {\n        return this.bounds.contains(position)\n      }\n    }\n\n    return false\n  }\n\n  calculateBounds () {\n    this.bounds = this.markerClusterer.getExtendedBounds(\n      new google.maps.LatLngBounds(\n        this.center,\n        this.center\n      )\n    )\n  }\n\n  updateIcon () {\n    const mCount = this.markers.length\n\n    const maxZoom = this.markerClusterer.getMaxZoom()\n\n    if (maxZoom !== null && this.map.getZoom() > maxZoom) {\n      this.clusterIcon.hide()\n\n      return\n    }\n\n    if (mCount < this.minClusterSize) {\n      // Min cluster size not yet reached.\n      this.clusterIcon.hide()\n\n      return\n    }\n\n    if (this.center) {\n      this.clusterIcon.setCenter(this.center)\n    }\n\n    this.clusterIcon.useStyle(\n      this.markerClusterer.getCalculator()(\n        this.markers,\n        this.markerClusterer.getStyles().length\n      )\n    )\n\n    this.clusterIcon.show()\n  }\n\n  isMarkerAlreadyAdded(marker: MarkerExtended): boolean {\n    if (this.markers.indexOf) {\n      return this.markers.includes(marker)\n    } else {\n      for (let i = 0; i < this.markers.length; i++) {\n        if (marker === this.markers[i]) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n}\n","/* eslint-disable filenames/match-regex */\n/* globals google */\nimport { Cluster } from './Cluster'\n\nimport {\n  MarkerExtended,\n  ClustererOptions,\n  ClusterIconStyle,\n  TCalculator,\n  ClusterIconInfo\n} from './types'\n\nconst CALCULATOR = function CALCULATOR(markers: MarkerExtended[], numStyles: number): ClusterIconInfo {\n  var index = 0\n\n  var title = \"\"\n\n  var count = markers.length.toString()\n\n  let dv: string | number = count\n\n  while (dv !== 0) {\n    // @ts-ignore\n    dv = parseInt(dv, 10) / 10\n\n    index++\n  }\n\n  index = Math.min(index, numStyles)\n\n  return {\n    text: count,\n    index: index,\n    title: title\n  }\n}\n\nconst BATCH_SIZE = 2000\n\nconst BATCH_SIZE_IE = 500\n\nconst IMAGE_PATH = \"https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m\"\n\nconst IMAGE_EXTENSION = \"png\"\n\nconst IMAGE_SIZES = [53, 56, 66, 78, 90]\n\nconst CLUSTERER_CLASS = \"cluster\"\n\nexport class Clusterer {\n  markers: MarkerExtended[];\n  clusters: Cluster[];\n  listeners: google.maps.MapsEventListener[];\n  activeMap: google.maps.Map | google.maps.StreetViewPanorama | null;\n  ready: boolean;\n  gridSize: number;\n  minClusterSize: number;\n  maxZoom: number | null;\n  styles: ClusterIconStyle[];\n  title: string;\n  zoomOnClick: boolean;\n  averageCenter: boolean;\n  ignoreHidden: boolean;\n  enableRetinaIcons: boolean;\n  imagePath: string;\n  imageExtension: string;\n  imageSizes: number[];\n  calculator: TCalculator;\n  batchSize: number;\n  batchSizeIE: number;\n  clusterClass: string;\n  timerRefStatic: number | null;\n\n  constructor(\n    map: google.maps.Map,\n    optMarkers: MarkerExtended[] = [],\n    optOptions: ClustererOptions = {}\n  ) {\n    this.extend(Clusterer, google.maps.OverlayView)\n\n    this.markers = []\n    this.clusters = []\n    this.listeners = []\n    this.activeMap = null\n    this.ready = false\n    this.gridSize = optOptions.gridSize || 60\n    this.minClusterSize = optOptions.minimumClusterSize || 2\n    this.maxZoom = optOptions.maxZoom || null\n    this.styles = optOptions.styles || []\n\n    this.title = optOptions.title || \"\"\n\n    this.zoomOnClick = true\n\n    if (optOptions.zoomOnClick !== undefined) {\n\n      this.zoomOnClick = optOptions.zoomOnClick\n    }\n\n    this.averageCenter = false\n\n    if (optOptions.averageCenter !== undefined) {\n\n      this.averageCenter = optOptions.averageCenter\n    }\n\n    this.ignoreHidden = false\n\n    if (optOptions.ignoreHidden !== undefined) {\n\n      this.ignoreHidden = optOptions.ignoreHidden\n    }\n\n    this.enableRetinaIcons = false\n\n    if (optOptions.enableRetinaIcons !== undefined) {\n      this.enableRetinaIcons = optOptions.enableRetinaIcons\n    }\n    this.imagePath = optOptions.imagePath || IMAGE_PATH\n\n    this.imageExtension = optOptions.imageExtension || IMAGE_EXTENSION\n\n    this.imageSizes = optOptions.imageSizes || IMAGE_SIZES\n\n    this.calculator = optOptions.calculator || CALCULATOR\n\n    this.batchSize = optOptions.batchSize || BATCH_SIZE\n\n    this.batchSizeIE = optOptions.batchSizeIE || BATCH_SIZE_IE\n\n    this.clusterClass = optOptions.clusterClass || CLUSTERER_CLASS\n\n    if (navigator.userAgent.toLowerCase().indexOf(\"msie\") !== -1) {\n      // Try to avoid IE timeout when processing a huge number of markers:\n      this.batchSize = this.batchSizeIE\n    }\n\n    this.timerRefStatic = null\n\n    this.setupStyles()\n\n    this.addMarkers(optMarkers, true)\n    // @ts-ignore\n    this.setMap(map) // Note: this causes onAdd to be called\n  }\n\n  onAdd () {\n    // @ts-ignore\n    this.activeMap = this.getMap()\n\n    this.ready = true\n\n    this.repaint()\n\n    // Add the map event listeners\n    this.listeners = [\n      google.maps.event.addListener(\n        // @ts-ignore\n        this.getMap(),\n        \"zoom_changed\",\n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        () => {\n          this.resetViewport(false)\n          // Workaround for this Google bug: when map is at level 0 and \"-\" of\n          // zoom slider is clicked, a \"zoom_changed\" event is fired even though\n          // the map doesn't zoom out any further. In this situation, no \"idle\"\n          // event is triggered so the cluster markers that have been removed\n          // do not get redrawn. Same goes for a zoom in at maxZoom.\n          if (\n            // @ts-ignore\n            this.getMap().getZoom() === (this.get(\"minZoom\") || 0) ||\n            // @ts-ignore\n            this.getMap().getZoom() === this.get(\"maxZoom\")\n          ) {\n            google.maps.event.trigger(this, \"idle\")\n          }\n        }\n      ),\n      google.maps.event.addListener(\n        // @ts-ignore\n        this.getMap(),\n        \"idle\",\n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        () => {\n          this.redraw()\n        }\n      )\n    ]\n  }\n\n  // eslint-disable-next-line @getify/proper-arrows/this\n  onRemove () {\n    // Put all the managed markers back on the map:\n    for (let i = 0; i < this.markers.length; i++) {\n      if (this.markers[i].getMap() !== this.activeMap) {\n        this.markers[i].setMap(this.activeMap)\n      }\n    }\n\n    // Remove all clusters:\n    for (let i = 0; i < this.clusters.length; i++) {\n      this.clusters[i].remove()\n    }\n\n    this.clusters = []\n\n    // Remove map event listeners:\n    for (let i = 0; i < this.listeners.length; i++) {\n      google.maps.event.removeListener(this.listeners[i])\n    }\n\n    this.listeners = []\n\n    this.activeMap = null\n\n    this.ready = false\n  }\n\n  draw () {}\n\n  setupStyles() {\n    if (this.styles.length > 0) {\n      return\n    }\n\n    for (let i = 0; i < this.imageSizes.length; i++) {\n      this.styles.push({\n        url: this.imagePath + (i + 1) + \".\" + this.imageExtension,\n        height: this.imageSizes[i],\n        width: this.imageSizes[i]\n      })\n    }\n  }\n\n  fitMapToMarkers () {\n    const markers = this.getMarkers()\n\n    const bounds = new google.maps.LatLngBounds()\n\n    for (let i = 0; i < markers.length; i++) {\n      const position = markers[i].getPosition()\n      if (position) {\n        bounds.extend(position)\n      }\n    }\n\n    // @ts-ignore\n    this.getMap().fitBounds(bounds)\n  }\n\n  getGridSize (): number {\n    return this.gridSize\n  }\n\n  setGridSize (gridSize: number) {\n    this.gridSize = gridSize\n  }\n\n  getMinimumClusterSize (): number {\n    return this.minClusterSize\n  }\n\n  setMinimumClusterSize (minimumClusterSize: number) {\n    this.minClusterSize = minimumClusterSize\n  }\n\n  getMaxZoom (): number | null {\n    return this.maxZoom\n  }\n\n  setMaxZoom (maxZoom: number) {\n    this.maxZoom = maxZoom\n  }\n\n  getStyles (): ClusterIconStyle[] {\n    return this.styles\n  }\n\n  setStyles (styles: ClusterIconStyle[]) {\n    this.styles = styles\n  }\n\n  getTitle (): string {\n    return this.title\n  }\n\n  setTitle (title: string) {\n    this.title = title\n  }\n\n  getZoomOnClick (): boolean {\n    return this.zoomOnClick\n  }\n\n  setZoomOnClick (zoomOnClick: boolean) {\n    this.zoomOnClick = zoomOnClick\n  }\n\n  getAverageCenter (): boolean {\n    return this.averageCenter\n  }\n\n  setAverageCenter(averageCenter: boolean) {\n    this.averageCenter = averageCenter\n  }\n\n  getIgnoreHidden(): boolean {\n    return this.ignoreHidden\n  }\n\n  setIgnoreHidden(ignoreHidden: boolean) {\n    this.ignoreHidden = ignoreHidden\n  }\n\n  getEnableRetinaIcons(): boolean {\n    return this.enableRetinaIcons\n  }\n\n  setEnableRetinaIcons(enableRetinaIcons: boolean) {\n    this.enableRetinaIcons = enableRetinaIcons\n  }\n\n  getImageExtension(): string {\n    return this.imageExtension\n  }\n\n  setImageExtension(imageExtension: string) {\n    this.imageExtension = imageExtension\n  }\n\n  getImagePath(): string {\n    return this.imagePath\n  }\n\n  setImagePath(imagePath: string) {\n    this.imagePath = imagePath\n  }\n\n  getImageSizes(): number[] {\n    return this.imageSizes\n  }\n\n  setImageSizes(imageSizes: number[]) {\n    this.imageSizes = imageSizes\n  }\n\n  getCalculator(): TCalculator {\n    return this.calculator\n  }\n\n  setCalculator(calculator: TCalculator) {\n    this.calculator = calculator\n  }\n\n  getBatchSizeIE(): number {\n    return this.batchSizeIE\n  }\n\n  setBatchSizeIE(batchSizeIE: number) {\n    this.batchSizeIE = batchSizeIE\n  }\n\n  getClusterClass(): string {\n    return this.clusterClass\n  }\n\n  setClusterClass(clusterClass: string) {\n    this.clusterClass = clusterClass\n  }\n\n  getMarkers(): MarkerExtended[] {\n    return this.markers\n  }\n\n  getTotalMarkers(): number {\n    return this.markers.length\n  }\n\n  getClusters(): Cluster[] {\n    return this.clusters\n  }\n\n  getTotalClusters(): number {\n    return this.clusters.length\n  }\n\n  addMarker(marker: MarkerExtended, optNoDraw: boolean) {\n    this.pushMarkerTo(marker)\n\n    if (!optNoDraw) {\n      this.redraw()\n    }\n  }\n\n  addMarkers(markers: MarkerExtended[], optNoDraw: boolean) {\n    for (let key in markers) {\n      if (markers.hasOwnProperty(key)) {\n        this.pushMarkerTo(markers[key])\n      }\n    }\n\n    if (!optNoDraw) {\n      this.redraw()\n    }\n  }\n\n  pushMarkerTo(marker: MarkerExtended) {\n    // If the marker is draggable add a listener so we can update the clusters on the dragend:\n    if (marker.getDraggable()) {\n      // eslint-disable-next-line @getify/proper-arrows/name, @getify/proper-arrows/this\n      google.maps.event.addListener(marker, \"dragend\", () => {\n        if (this.ready) {\n          marker.isAdded = false\n\n          this.repaint()\n        }\n      })\n    }\n\n    marker.isAdded = false\n\n    this.markers.push(marker)\n  }\n\n  removeMarker_ (marker: MarkerExtended): boolean {\n    let index = -1\n\n    if (this.markers.indexOf) {\n      index = this.markers.indexOf(marker)\n    } else {\n      for (let i = 0; i < this.markers.length; i++) {\n        if (marker === this.markers[i]) {\n          index = i\n\n          break\n        }\n      }\n    }\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false\n    }\n\n    marker.setMap(null)\n\n    this.markers.splice(index, 1) // Remove the marker from the list of managed markers\n\n    return true\n  }\n\n  removeMarker (marker: MarkerExtended, optNoDraw: boolean): boolean {\n    const removed = this.removeMarker_(marker)\n\n    if (!optNoDraw && removed) {\n      this.repaint()\n    }\n\n    return removed\n  }\n\n  removeMarkers (markers: MarkerExtended[], optNoDraw: boolean): boolean {\n    let removed = false\n\n    for (let i = 0; i < markers.length; i++) {\n      removed = removed || this.removeMarker_(markers[i])\n    }\n\n    if (!optNoDraw && removed) {\n      this.repaint()\n    }\n\n    return removed\n  }\n\n  clearMarkers () {\n    this.resetViewport(true)\n\n    this.markers = []\n  }\n\n  repaint () {\n    const oldClusters = this.clusters.slice()\n\n    this.clusters = []\n\n    this.resetViewport(false)\n\n    this.redraw()\n\n    // Remove the old clusters.\n    // Do it in a timeout to prevent blinking effect.\n    setTimeout(\n      function timeout() {\n        for (let i = 0; i < oldClusters.length; i++) {\n          oldClusters[i].remove()\n        }\n      },\n      0\n    )\n  }\n\n  getExtendedBounds (bounds: google.maps.LatLngBounds): google.maps.LatLngBounds {\n    // @ts-ignore\n    const projection = this.getProjection()\n    // Convert the points to pixels and the extend out by the grid size.\n    const trPix = projection.fromLatLngToDivPixel(\n      // Turn the bounds into latlng.\n      new google.maps.LatLng(\n        bounds.getNorthEast().lat(),\n        bounds.getNorthEast().lng()\n      )\n    )\n\n    trPix.x += this.gridSize\n    trPix.y -= this.gridSize\n\n    const blPix = projection.fromLatLngToDivPixel(\n      // Turn the bounds into latlng.\n      new google.maps.LatLng(\n        bounds.getSouthWest().lat(),\n        bounds.getSouthWest().lng()\n      )\n    )\n\n    blPix.x -= this.gridSize\n    blPix.y += this.gridSize\n\n    // Extend the bounds to contain the new bounds.\n    bounds.extend(\n      // Convert the pixel points back to LatLng nw\n      projection.fromDivPixelToLatLng(trPix)\n    )\n\n    bounds.extend(\n      // Convert the pixel points back to LatLng sw\n      projection.fromDivPixelToLatLng(blPix)\n    )\n\n    return bounds\n  }\n\n  redraw () {\n    // Redraws all the clusters.\n    this.createClusters(0)\n  }\n\n  resetViewport (optHide: boolean) {\n    // Remove all the clusters\n    for (let i = 0; i < this.clusters.length; i++) {\n      this.clusters[i].remove()\n    }\n\n    this.clusters = []\n\n    // Reset the markers to not be added and to be removed from the map.\n    for (let i = 0; i < this.markers.length; i++) {\n      const marker = this.markers[i]\n\n      marker.isAdded = false\n\n      if (optHide) {\n        marker.setMap(null)\n      }\n    }\n  }\n\n  distanceBetweenPoints (p1: google.maps.LatLng, p2: google.maps.LatLng): number {\n    const R = 6371 // Radius of the Earth in km\n\n    const dLat = (p2.lat() - p1.lat()) * Math.PI / 180\n    const dLon = (p2.lng() - p1.lng()) * Math.PI / 180\n\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n      Math.sin(dLon / 2) * Math.sin(dLon / 2)\n\n    return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)))\n  }\n\n  isMarkerInBounds (marker: MarkerExtended, bounds: google.maps.LatLngBounds): boolean {\n    const position = marker.getPosition()\n\n    if (position) {\n      return bounds.contains(position)\n    }\n\n    return false\n  }\n\n  addToClosestCluster (marker: MarkerExtended) {\n    let cluster\n\n    let distance = 40000 // Some large number\n\n    let clusterToAddTo = null\n\n    for (let i = 0; i < this.clusters.length; i++) {\n      cluster = this.clusters[i]\n\n      const center = cluster.getCenter()\n\n      const position = marker.getPosition()\n\n      if (center && position) {\n        const d = this.distanceBetweenPoints(center, position)\n\n        if (d < distance) {\n          distance = d\n\n          clusterToAddTo = cluster\n        }\n      }\n    }\n\n    if (\n      clusterToAddTo &&\n      clusterToAddTo.isMarkerInClusterBounds(marker)\n    ) {\n      clusterToAddTo.addMarker(marker)\n    } else {\n      cluster = new Cluster(this)\n\n      cluster.addMarker(marker)\n\n      this.clusters.push(cluster)\n    }\n  }\n\n  createClusters (iFirst: number) {\n    if (!this.ready) {\n      return\n    }\n\n    // Cancel previous batch processing if we're working on the first batch:\n    if (iFirst === 0) {\n      /**\n       * This event is fired when the <code>Clusterer</code> begins\n       *  clustering markers.\n       * @name Clusterer#clusteringbegin\n       * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n       * @event\n       */\n      google.maps.event.trigger(this, \"clusteringbegin\", this)\n\n      if (this.timerRefStatic !== null) {\n        window.clearTimeout(this.timerRefStatic)\n\n        delete this.timerRefStatic\n      }\n    }\n\n    // Get our current map view bounds.\n    // Create a new bounds object so we don't affect the map.\n    //\n    // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n    // @ts-ignore\n    const mapBounds = this.getMap().getZoom() > 3\n      ? new google.maps.LatLngBounds(\n        // @ts-ignore\n        this.getMap().getBounds().getSouthWest(),\n        // @ts-ignore\n        this.getMap().getBounds().getNorthEast()\n      )\n      : new google.maps.LatLngBounds(\n        new google.maps.LatLng(\n          85.02070771743472,\n          -178.48388434375\n        ),\n        new google.maps.LatLng(\n          -85.08136444384544,\n          178.00048865625\n        )\n      )\n\n    const bounds = this.getExtendedBounds(mapBounds)\n\n    const iLast = Math.min(iFirst + this.batchSize, this.markers.length)\n\n    for (let i = iFirst; i < iLast; i++) {\n      const marker = this.markers[i]\n\n      if (!marker.isAdded && this.isMarkerInBounds(marker, bounds)) {\n        if (\n          !this.ignoreHidden ||\n          (\n            this.ignoreHidden &&\n            marker.getVisible()\n          )\n        ) {\n          this.addToClosestCluster(marker)\n        }\n      }\n    }\n\n    if (iLast < this.markers.length) {\n      this.timerRefStatic = window.setTimeout(\n        // eslint-disable-next-line @getify/proper-arrows/this, @getify/proper-arrows/name\n        () => {\n          this.createClusters(iLast)\n        },\n        0\n      )\n    } else {\n      this.timerRefStatic = null\n\n      /**\n       * This event is fired when the <code>Clusterer</code> stops\n       *  clustering markers.\n       * @name Clusterer#clusteringend\n       * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n       * @event\n       */\n      google.maps.event.trigger(this, \"clusteringend\", this)\n    }\n  }\n\n  extend(obj1: any, obj2: any): any {\n    return (function applyExtend(object: any) {\n      // eslint-disable-next-line guard-for-in\n      for (let property in object.prototype) {\n        // @ts-ignore\n        this.prototype[property] = object.prototype[property]\n      }\n\n      // @ts-ignore\n      return this\n    }).apply(obj1, [obj2])\n  }\n}\n"],"names":["ClusterIcon","cluster","styles","getClusterer","extend","google","maps","OverlayView","className","this","getClusterClass","center","undefined","div","sums","visible","boundsChangedListener","url","height","width","anchorText","anchorIcon","textColor","textSize","textDecoration","fontWeight","fontStyle","fontFamily","backgroundPosition","setMap","getMap","onAdd","cMouseDownInCluster","cDraggingMapByCluster","document","createElement","show","getPanes","overlayMouseTarget","appendChild","event","addListener","addDomListener","markerClusterer","_this","trigger","getZoomOnClick","maxZoom","getMaxZoom","bounds","getBounds","fitBounds","setTimeout","getZoom","setZoom","cancelBubble","stopPropagation","onRemove","parentNode","hide","removeListener","clearInstanceListeners","removeChild","draw","getPosFromLatLng","x","style","top","y","left","display","divTitle","img","bp","split","spriteH","parseInt","replace","spriteV","pos","title","getTitle","cssText","createCss","enableRetinaIcons","innerHTML","text","useStyle","Math","min","length","max","index","setCenter","push","join","latlng","getProjection","fromLatLngToDivPixel","Cluster","map","gridSize","getGridSize","minClusterSize","getMinimumClusterSize","averageCenter","getAverageCenter","markers","clusterIcon","getStyles","getSize","getMarkers","getCenter","LatLngBounds","i","position","getPosition","remove","addMarker","marker","isMarkerAlreadyAdded","LatLng","lat","lng","calculateBounds","isAdded","mCount","updateIcon","isMarkerInClusterBounds","contains","getExtendedBounds","getCalculator","indexOf","includes","CALCULATOR","numStyles","count","toString","dv","BATCH_SIZE","BATCH_SIZE_IE","IMAGE_PATH","IMAGE_EXTENSION","IMAGE_SIZES","CLUSTERER_CLASS","Clusterer","optMarkers","optOptions","clusters","listeners","activeMap","ready","minimumClusterSize","zoomOnClick","ignoreHidden","imagePath","imageExtension","imageSizes","calculator","batchSize","batchSizeIE","clusterClass","navigator","userAgent","toLowerCase","timerRefStatic","setupStyles","addMarkers","repaint","resetViewport","get","redraw","fitMapToMarkers","setGridSize","setMinimumClusterSize","setMaxZoom","setStyles","setTitle","setZoomOnClick","setAverageCenter","getIgnoreHidden","setIgnoreHidden","getEnableRetinaIcons","setEnableRetinaIcons","getImageExtension","setImageExtension","getImagePath","setImagePath","getImageSizes","setImageSizes","setCalculator","getBatchSizeIE","setBatchSizeIE","setClusterClass","getTotalMarkers","getClusters","getTotalClusters","optNoDraw","pushMarkerTo","key","hasOwnProperty","getDraggable","_this2","removeMarker_","splice","removeMarker","removed","removeMarkers","clearMarkers","oldClusters","slice","projection","trPix","getNorthEast","blPix","getSouthWest","fromDivPixelToLatLng","createClusters","optHide","distanceBetweenPoints","p1","p2","dLat","PI","dLon","a","sin","cos","atan2","sqrt","isMarkerInBounds","addToClosestCluster","distance","clusterToAddTo","d","iFirst","window","clearTimeout","mapBounds","iLast","getVisible","_this3","obj1","obj2","object","property","prototype","apply"],"mappings":"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"}